{"version":3,"file":"ngb-date-parser-formatter.js","sourceRoot":"","sources":["../../../src/datepicker/ngb-date-parser-formatter.ts"],"names":[],"mappings":"OAAO,EAAC,SAAS,EAAE,SAAS,EAAE,QAAQ,EAAC,MAAM,cAAc;AAE3D;;;;;GAKG;AACH;IACA;;;;;;OAMG;IACH,KAAK,CAAC,KAAa,IAAG,CAAC;IACvB;;;;;;OAMG;IACH,MAAM,CAAC,IAAmB,IAAG,CAAC;AAC9B,CAAC;AACD,+CAA+C,sBAAsB;IACrE;;;OAGG;IACH,KAAK,CAAC,KAAa;QACf,EAAE,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;YACV,MAAM,gBAAgB,CAAC,SAAS,GAAG,KAAK,CAAC,IAAI,EAAE,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;YAC3D,EAAE,CAAC,CAAC,SAAS,CAAC,MAAM,KAAK,CAAC,IAAI,QAAQ,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;gBACrD,MAAM,CAAC,EAAC,IAAI,EAAE,SAAS,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,EAAE,KAAK,EAAE,IAAI,EAAE,GAAG,EAAE,IAAI,EAAC,CAAC;YACjE,CAAC;YAAC,IAAI,CAAC,EAAE,CAAC,CAAC,SAAS,CAAC,MAAM,KAAK,CAAC,IAAI,QAAQ,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,IAAI,QAAQ,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;gBACtF,MAAM,CAAC,EAAC,IAAI,EAAE,SAAS,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,EAAE,KAAK,EAAE,SAAS,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,EAAE,GAAG,EAAE,IAAI,EAAC,CAAC;YACpF,CAAC;YAAC,IAAI,CAAC,EAAE,CAAC,CAAC,SAAS,CAAC,MAAM,KAAK,CAAC,IAAI,QAAQ,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,IAAI,QAAQ,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,IAAI,QAAQ,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;gBAChH,MAAM,CAAC,EAAC,IAAI,EAAE,SAAS,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,EAAE,KAAK,EAAE,SAAS,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,EAAE,GAAG,EAAE,SAAS,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,EAAC,CAAC;YACvG,CAAC;QACH,CAAC;QACD,MAAM,CAAC,IAAI,CAAC;IACd,CAAC;IACH;;;OAGG;IACH,MAAM,CAAC,IAAmB;QACtB,MAAM,CAAC,IAAI;YACP,GAAG,IAAI,CAAC,IAAI,IAAI,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,SAAS,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,EAAE,IAAI,QAAQ,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG,SAAS,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG,EAAE,EAAE;YACpH,EAAE,CAAC;IACT,CAAC;AACH,CAAC;AAAA","sourcesContent":["import {padNumber, toInteger, isNumber} from '../util/util';\nimport {NgbDateStruct} from './ngb-date-struct';\n/**\n * Abstract type serving as a DI token for the service parsing and formatting dates for the NgbInputDatepicker\n * directive. A default implementation using the ISO 8601 format is provided, but you can provide another implementation\n * to use an alternative format.\n * @abstract\n */\nexport abstract class NgbDateParserFormatter {\n/**\n * Parses the given value to an NgbDateStruct. Implementations should try their best to provide a result, even\n * partial. They must return null if the value can't be parsed.\n * @abstract\n * @param {?} value the value to parse\n * @return {?}\n */\nparse(value: string) {}\n/**\n * Formats the given date to a string. Implementations should return an empty string if the given date is null,\n * and try their best to provide a partial result if the given date is incomplete or invalid.\n * @abstract\n * @param {?} date the date to format as a string\n * @return {?}\n */\nformat(date: NgbDateStruct) {}\n}\nexport class NgbDateISOParserFormatter extends NgbDateParserFormatter {\n/**\n * @param {?} value\n * @return {?}\n */\nparse(value: string): NgbDateStruct {\n    if (value) {\n      const /** @type {?} */ dateParts = value.trim().split('-');\n      if (dateParts.length === 1 && isNumber(dateParts[0])) {\n        return {year: toInteger(dateParts[0]), month: null, day: null};\n      } else if (dateParts.length === 2 && isNumber(dateParts[0]) && isNumber(dateParts[1])) {\n        return {year: toInteger(dateParts[0]), month: toInteger(dateParts[1]), day: null};\n      } else if (dateParts.length === 3 && isNumber(dateParts[0]) && isNumber(dateParts[1]) && isNumber(dateParts[2])) {\n        return {year: toInteger(dateParts[0]), month: toInteger(dateParts[1]), day: toInteger(dateParts[2])};\n      }\n    }\n    return null;\n  }\n/**\n * @param {?} date\n * @return {?}\n */\nformat(date: NgbDateStruct): string {\n    return date ?\n        `${date.year}-${isNumber(date.month) ? padNumber(date.month) : ''}-${isNumber(date.day) ? padNumber(date.day) : ''}` :\n        '';\n  }\n}\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"]}